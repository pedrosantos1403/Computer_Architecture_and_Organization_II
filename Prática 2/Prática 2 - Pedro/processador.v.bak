//Módulo que representa o processador

module pratica_2 (DIN, Resetn, Clock, Run, Done, ADDR, DOUT, W);
	input [15:0] DIN;
	input Resetn, Clock, Run;
	output reg Done;
	output [15:0] ADDR, DOUT;
	output W;
	
	
	//Variáveis
	
	//Sinais de Controle
	reg IRin, Ain, Gin;	//Sinais de controle de escrita nos registradores IR, A e G	
	reg [9:0] Select;	//Sinais de controle: Seleção do mux 
								// Select[7:0]=Rout, Select[8]=Gout, Select[9]=DINout
 	reg [7:0] Rin;		//Sinais de controle de escrita nos registradores R0 a R7
	reg [2:0] AluOp;	//Sinal de controle que define a operação a ULA
	reg AddrIn, DoutIn, IncrPc, W_D;		//Sinais de controle relacionados a PC e acesso a memória 
	
	//Demais conexões
	wire [3:0] I;						//Opcode da instrução
	wire [7:0] Xreg, Yreg; 			//Sinal decodificado dos operandos
	wire [2:0] Tstep_Q;				//Sinal com o ciclo atual				
	
	wire [15:0]A, G, Result;							
	wire [15:0] R0, R1, R2, R3, R4, R5, R6, R7;
	wire [15:0]BusWires, IR;	
	
	
	Mux10to1 mux10to1(Select, DIN, R0, R1, R2, R3, R4, R5, R6, R7, G,BusWires);
	wire Clear = Done | ~Resetn;
	upcount Tstep (Clear, Clock, Tstep_Q);

	//Instrução: IIIIXXXYYY
	assign I = IR[15:12];
	dec3to8 decX (IR[11:9], 1, Xreg);
	dec3to8 decY (IR[8:6], 1'b1, Yreg);
	
	always @(Tstep_Q or I or Xreg or Yreg) begin
		//Inicialização
		Select = 10'b0000000000;
		Done = 1'b0;
		IRin = 1'b0;
		Ain = 1'b0;	
		Gin = 1'b0;
		AluOp = 3'b000;
		Rin = 8'b00000000;
		AddrIn = 1'b0;
		DoutIn = 1'b0;
		IncrPc = 1'b0;
		W_D = 1'b0;		

		case (Tstep_Q)
			3'b000: // store DIN in IR in time step 0
			begin
				IRin = 1'b1;		//Habilita escrita em IR
				IncrPc=1'b1;
				
			end
			3'b001: //define signals in time step 1
				case (I)
					4'b0000:								//mv = 0000
					begin
						Select[7:0] = Yreg;			//Rout = Yreg
						Rin = Xreg;						//Seleciona o registrador para ser escrito
						Done = 1'b1;
					end
					4'b0001:								// mvi = 0001
					begin
						Select[7:0] = 8'b00000000;	//Rout = 0
						Select[9] = 1'b1;				//DINout = 1
						Rin = Xreg;						//Seleciona o registrador para ser escrito
						Done = 1'b1;
					end
					4'b0010,								// add = 0010
					4'b0011,								// sub = 0011
					4'b0100,								// and = 0100
					4'b0101,								// slt = 0101
					4'b0110,								// sll = 0110
					4'b0111:								// srl = 0111	
					begin
						Select[7:0] = Xreg;			//Rout = Xreg
						Ain = 1'b1;						// Habilita escrita em A
					end
					4'b1000,								// ld = 1000
					4'b1001:								// st = 1001
					begin
						Select[7:0] = Yreg;
						AddrIn = 1'b1;
					end
				endcase
			3'b010: //define signals in time step 2
				case (I)	
					4'b0010:								// add = 0010
					begin
						Select[7:0] = Yreg;			//Rout = Yreg
						Gin = 1'b1;						// Habilita escrita em G
					end
					4'b0011:								// sub = 0011
					begin
						Select[7:0] = Yreg;			//Rout = Yreg
						Gin = 1'b1;						// Habilita escrita em G
						AluOp = 3'b001;
					end
					4'b0100:								// and = 0100
					begin
						Select[7:0] = Yreg;			//Rout = Yreg
						Gin = 1'b1;						// Habilita escrita em G
						AluOp = 3'b010;
					end
					4'b0101:								// slt = 0101
					begin
						Select[7:0] = Yreg;			//Rout = Yreg
						Gin = 1'b1;						// Habilita escrita em G
						AluOp = 3'b011;
					end
					4'b0110:								// sll = 0110
					begin
						Select[7:0] = Yreg;			//Rout = Yreg
						Gin = 1'b1;						// Habilita escrita em G
						AluOp = 3'b100;
					end
					4'b0111:								// srl = 0111
					begin
						Select[7:0] = Yreg;			//Rout = Yreg
						Gin = 1'b1;						// Habilita escrita em G
						AluOp = 3'b101;
					end					
					
					4'b1001:								// st = 1001
					begin	
						Select[7:0] = Xreg;
						DoutIn = 1'b1;
						W_D = 1'b1;
					end
				endcase
			3'b011: //define signals in time step 3
				case (I)
					4'b0010,								// add = 0010		
					4'b0011,								// sub = 0011
					4'b0100,								// and = 0100
					4'b0101,								// slt = 0101
					4'b0110,								// sll = 0110
					4'b0111:								// srl = 0111
					begin
						Select[8] = 1'b1;				// Gout = 1;
						Select[7:0] = 8'b00000000;	// Rout = 0;
						Rin = Xreg;
						Done = 1'b1;
					end
					4'b1000:								// ld = 1000
					begin
						Select[7:0] = 8'b00000000;
						Select[9] = 1'b1;
						Rin = Xreg;
						Done = 1'b1;
					end
					4'b1001:
					begin
						Done = 1'b1;
					end
				endcase
		endcase
	end
	
	// Registradores 
	regn reg_0 (BusWires, Rin[7], Clock, R0);
	regn reg_1 (BusWires, Rin[6], Clock, R1);
	regn reg_2 (BusWires, Rin[5], Clock, R2);
	regn reg_3 (BusWires, Rin[4], Clock, R3);
	regn reg_4 (BusWires, Rin[3], Clock, R4);
	regn reg_5 (BusWires, Rin[2], Clock, R5);
	regn reg_6 (BusWires, Rin[1], Clock, R6);
	regn_pc reg_7 (BusWires, Rin[0], Clock, R7, IncrPc);
	regn reg_A (BusWires, Ain, Clock, A);
	regn reg_G (Result, Gin, Clock, G);
	regn reg_IR (DIN, IRin, Clock, IR);
	regn reg_addr (BusWires, AddrIn, Clock, ADDR);
	regn reg_dout (BusWires, DoutIn, Clock, DOUT);
	regn reg_W (W_D, 1'b1, Clock, W);
	
		
	
	//ULA
	ALUn alun(AluOp,A,BusWires,Result);

	
endmodule